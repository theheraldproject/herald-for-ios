//
//  DayCodes.swift
//
//  Copyright 2020 VMware, Inc.
//  SPDX-License-Identifier: MIT
//

import Foundation

/**
 Day codes are derived from a shared secret that has been agreed with the central server on registration.
 Given a shared secret, a sequence of forward secure day codes is created by recursively hashing (SHA)
 the hash of the shared secret, and using the hashes in reverse order; a day code is generated by taking
 the first eight bytes of a hash as a long value code. It is cryptographically challenging to predict the next
 code given the previous codes. Each day is allocated a day code up to a finite number of days for simplicity.
 */
protocol DayCodes {
    /// Get beacon code seed for a particular day. This is used for deriving the beacon codes for the day.
    func seed(_ timestamp: Timestamp) -> (BeaconCodeSeed, Day)?
}

/// Shared secret between device and server for deriving day codes and beacon codes.
typealias SharedSecret = Data

/// Day codes are published by the server to enable on-device matching in a de-centralised solution.
typealias DayCode = Int64

/// Day is the number of whole days since epoch (2020-01-01 00:00:00)
typealias Day = UInt

/// Beacon code seed is derived from the day code. This is used to derive the beacon codes for the day.
typealias BeaconCodeSeed = Int64

/// Timestamp has been abstracted to enable change from Date if required in the future.
typealias Timestamp = Date

class ConcreteDayCodes : DayCodes {
    private let logger = ConcreteSensorLogger(subsystem: "Sensor", category: "Payload.ConcreteDayCodes")
    private let epoch = ConcreteDayCodes.timeIntervalSince1970("2020-01-01T00:00:00+0000")!
    private var values:[DayCode]
    
    init(_ sharedSecret: SharedSecret) {
        let days = 365 * 5
        values = ConcreteDayCodes.dayCodes(sharedSecret, days: days)
    }
    
    static func timeIntervalSince1970(_ from: String) -> UInt64? {
        let formatter = DateFormatter()
        formatter.calendar = Calendar(identifier: .iso8601)
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXX"
        guard let date = formatter.date(from: from) else {
            return nil
        }
        return UInt64(date.timeIntervalSince1970)
    }
    
    static func dayCodes(_ sharedSecret: SharedSecret, days: Int) -> [DayCode] {
        var hash = SHA.hash(data: sharedSecret)
        var values = [DayCode](repeating: 0, count: days)
        for i in (0 ... (days - 1)).reversed() {
            values[i] = JavaData.byteArrayToLong(digest: hash)
            let hashData = Data(hash)
            hash = SHA.hash(data: hashData)
        }
        return values
    }
    
    static func beaconCodeSeed(_ dayCode: DayCode) -> BeaconCodeSeed {
        let data = withUnsafeBytes(of: dayCode) { Data($0) }
        let reversed: [UInt8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
        let hash = SHA.hash(data: Data(reversed))
        let seed = BeaconCodeSeed(JavaData.byteArrayToLong(digest: hash))
        return seed
    }
    
    private func day(_ timestamp: Timestamp) -> Day? {
        let time = UInt64(NSDate(timeIntervalSince1970: timestamp.timeIntervalSince1970).timeIntervalSince1970)
        let (epochDay,_) = (time - epoch).dividedReportingOverflow(by: UInt64(24 * 60 * 60))
        let day = Day(epochDay)
        guard day >= 0, day < values.count else {
            logger.fault("Day out of range")
            return nil
        }
        return day
    }
    
    private func get(_ timestamp: Timestamp) -> DayCode? {
        guard let day = day(timestamp) else {
            logger.fault("Day out of range")
            return nil
        }
        return values[Int(day)]
    }
    
    func seed(_ timestamp: Timestamp) -> (BeaconCodeSeed, Day)? {
        guard let day = day(timestamp), let dayCode = get(timestamp) else {
            logger.fault("Day out of range")
            return nil
        }
        let seed = ConcreteDayCodes.beaconCodeSeed(dayCode)
        return (seed, day)
    }
}
